---
title: "Light OJ 1120: Rectangle Union Editorial with Multiset"
date: 2020-10-01T21:51:20+06:00
draft: false
tags: ["LOJ 1120", "Light OJ 1120", "Line Sweeping", "Multiset", "Editorial"]
index: true
description: "Light Oj 1120: Rectangle Union Editorial with Multiset"
highlight: true
---

##

Problem Link: [Click Here](http://lightoj.com/volume_showproblem.php?problem=1120)

![](https://lh3.googleusercontent.com/MYHzwBqJGGxl5gw1OR5vZiYMcYVemWvesF9I6hvFXgUGZ6DQyG0_UyuVbf0knTKHPKBuHz923pK3TRWDyBggmzwuz_S8PqhlUJmLD2xGFhwR1OhWj0zpmFPUNDXGadeEvZSBsvw4S_t6VFmoWQ)

**প্রবলেমঃ** $n$ সংখ্যক “Axis Parallel” আয়তক্ষেত্রের বামদিকের নিচের কর্নার এবং ডানদিকের উপরের কর্নারের কো-অর্ডিনেট দেওয়া থাকবে । বের করতে হবে আয়তক্ষেত্রগুলো দ্বারা আবদ্ধ ক্ষেত্রের ক্ষেত্রফল কত ?

Example: উপরের চিত্রের হলুদ আয়তক্ষত্রের কো-অর্ডিনেটদ্বয় হচ্ছে $A(0, 2)$ এবং $X(3, 6)$ । সবুজ আয়তক্ষত্রের কো-অর্ডিনেটদ্বয়ঃ $C(2, 1)$ ও $Y(5, 4)$ এবং নীল আয়তক্ষত্রের কো-অর্ডিনেটদ্বয়ঃ $W(1, 3)$ ও $M(6, 7)$ । তাহলে এই তিনটি আয়তক্ষেত্রের মিলিত আবদ্ধ ক্ষেত্রের (ধূসর শেড করা অংশ) ক্ষেত্রফলঃ $31$ ।

**সলিউশনঃ** প্রথমে আমরা বামদিক থেকে ডানদিকে এগোতে শুরু করি । $A$ বিন্দু থেকে এগোতে থাকলে দেখা যাচ্ছে যে $ABGF$ একটি আয়তক্ষেত্র গঠন করেছে । এর পরবর্তী আয়তক্ষেত্র হচ্ছে $BSIH$ । এভাবে যেতে থাকলে $CDJI, DNLJ$ এবং $OPML$ আয়তক্ষেত্র পাওয়া যায়। সুতরাং,

$(ABGF + BSIH + CDJI + DNLJ + OPML)$ এর ক্ষেত্রফল = উদাহরণের তিনটি আয়তক্ষেত্রের মিলিত আবদ্ধ ক্ষেত্রের ক্ষেত্রফল ।

এখানে দেখা যাচ্ছে, মূল কাজ হচ্ছে সাব-আয়তক্ষেত্রগুলো বের করা । ভালমত লক্ষ্য করলে দেখা যাবে পরপর দুটো $X-$স্থানাংক এবং এদের মধ্যকার সর্বনিম্ন এবং সর্বোচ্চ $Y-$স্থানাংক বের করতে পারলেই সাব-আয়তক্ষেত্রগুলো পাওয়া যাবে । যেমনঃ $ABFG$ আয়তক্ষেত্রের জন্য, পরপর দুটো $X$ স্থানাংকের বিন্দু হচ্ছে $A$ এবং $W$। $B$ এবং $W$ বিন্দুর $X-$স্থানাংক একই । 
এদের মধ্যকার সর্বনিম্ন $Y-$স্থানাংকের বিন্দু হচ্ছে $A$ (এবং $B$) । আর সর্বোচ্চ $Y-$স্থানাংকের বিন্দু হচ্ছে $F$ (এবং $G$) । $F$ বিন্দুর $Y-$স্থানাংক বের করা তেমন কোনো কঠিন কাজ না । $F$ বিন্দুটি হলুদ আয়তক্ষেত্রের উপরের বাহুর একটি বিন্দু । অর্থাৎ $X$ এবং $F$ বিন্দুর $Y-$স্থানাংক একই । আর $X$ বিন্দুর স্থানাংক ইনপুট থেকেই পাওয়া যাচ্ছে । তো, স্থানাংকগুলো বের হয়ে গেলে $(x_2 – x_1) \times (y_2 – y_1)$ সূত্র থেকেই কোরেসপন্ডিং আয়তক্ষেত্রের ক্ষেত্রফল বের করে ফেলা সম্ভব । এখানে আরও একটি জিনিস লক্ষণীয়, আমরা যেহেতু বামদিক থেকে ডানদিকে যাচ্ছি সেহেতু কোনো আয়তক্ষত্রের ডানদিকের বাহু অতিক্রম করে গেলে সেই আয়তক্ষেত্রের কোনো কিছু আর পরবর্তী ক্যালকুলেশনে ব্যবহার করা যাবে না । ওই আয়তক্ষেত্র সম্পর্কিত ক্যালকুলেশন ওখানেই শেষ ।

এখন, এটার কোড কীভাবে করা যায়?

কোডিং এপ্রোচ **C++** এ আলোচনা করব । একটা স্ট্রাকচারে আয়তক্ষেত্রের স্থানাংকগুলো থাকবে । যেহেতু বামদিক থেকে ডানদিক থেকে যাচ্ছি, তাই স্ট্রাকচারের একটি ইনডেক্সে একটি আয়তক্ষেত্রের বামদিকের $X-$স্থানাংক $x_1$ এবং $y_1, y_2$ থাকবে । আরেকটি ইনডেক্সে ডানদিকের $X-$স্থানাংক $x_2$ এবং $y_1, y_2$ থাকবে । $X-$স্থানাংক বামদিকের নাকি ডানদিকের সেটা বুঝার সুবিধার্থে স্ট্রাকচারে $state$ নামে একটা ভ্যারিয়েবল থাকবে । $state = 0$ হলে বামদিকের স্থানাংক আর $state = 1$ হলে ডানদিকের স্থানাংক । ইনপুট নেওয়া শেষ হলে স্ট্রাকচার $Ascending$ সর্ট করা হবে । সর্ট করার সময় প্রথমে $x$ কমপেয়ার করা হবে, $x$ স্থানাংক সমান হলে $state$ কমপেয়ার করা হবে । সর্ট করা শেষে স্ট্রাকচার থেকে একটি একটি করে $X-$স্থানাংক নিতে হবে আর পরপর দুটো $X-$স্থানাংকের মধ্যকার সর্বোচ্চ এবং সর্বনিম্ন $Y-$স্থানাংকগুলো পাওয়ার জন্য $Y-$স্থানাংকগুলো $Multiset-$এ ইনসার্ট করতে হবে । যখন কোনো আয়তক্ষেত্রের ডানদিকের বাহুর স্থানাংক অতিক্রম করব অর্থাৎ, স্ট্রাকচারের কোনো ইনডেক্সের $state = 1$ পাব তখন তার কোরেসপন্ডিং $Y-$স্থানাংকগুলো $Multiset$ থেকে ইরেজ করে দিতে হবে । পরপর দুটো $X-$স্থানাংক এবং এদের মধ্যকার সর্বোচ্চ এবং সর্বনিম্ন $Y-$স্থানাংক থেকে সহজেই সাব-আয়তক্ষেত্রগুলোর ক্ষেত্রফল পাওয়া যাবে আর সেগুলোর ক্ষেত্রফল যোগ করলেই সেখান থেকে সম্পূর্ণ ক্ষেত্রফল পাওয়া যাবে । এখানে একটি ব্যাপার লক্ষণীয়, $ABGF$ আয়তক্ষেত্রের ক্ষেত্রফল বের করার সময় যদিও আমরা নীল আয়তক্ষেত্রের $W$ বিন্দুর $X-$স্থানাংক ব্যবহার করেছি কিন্তু তখন আমরা এই নীল আয়তক্ষেত্রের কোন $Y-$স্থানাংক ব্যবহার করিনি যেহেতু $ABGF$ আয়তক্ষেত্র $WH$ রেখার বামদিকে অবস্থিত । তাই আয়তক্ষেত্রগুলোর ক্যাককুলেশন এবং $Multiset$ এ $Y-$স্থানাংকগুলোর ইনসার্টিং/ইরেজিং আগে-পরে করার ব্যাপারে কেয়ারফুল থাকতে হবে ।

**বাম থেকে ডানে যাওয়ার এই বেসিক আইডিয়াটাই লাইন সুইপিং।**


* **Multiset:** $Multiset$ হচ্ছে এমন একটি কনটেইনার যেখানে ইনসার্ট করা ভ্যালুগুলো বাই ডিফল্ট $Ascending$  সর্টেড হয়ে থাকে ।

* **Declaration:** $multiset \<int> mset;$

* **Iterator:** $multiset \<int> ::iterator \space it;$


**Some Functions:**

* **Insert:** $mset.insert(num);$ [$num$ ভ্যারিয়েবলের ভ্যালু ইনসার্ট করে]

* **Erase (by iterator):** $mset.erase(it);$ [$Iterator$-এর পয়েন্টকৃত মেমরির ভ্যালু ইরেজ করে]

* **Erase (by value):** $mset.erase(num);$ [$num$-র সমান সকল ভ্যালু ইরেজ করে]

* **Find (by value):** $mset.find(num);$ [$Multiset$ থেকে $num$-র সমান একটি ভ্যালু খুঁজে বের করে তার $iterator$ রিটার্ন করে । খুঁজে না পেলে $mset.end()$ এর সমান $iterator$ রিটার্ন করে ]

> $Multiset$ থেকে $num$ এর সমান একটি ভ্যালু ইরেজ করার উপায়ঃ

$it = mset.find(num);$

$if  ( it != mset.end()) \lbrace$

$\quad mset.erase(it);$

$\rbrace$

> $Multiset$ এর মিনিমাম ভ্যালুঃ

$if(mset.size() != 0) \lbrace$

$\quad it = mset.begin();$

$\quad minimum = *it;$

$\rbrace$

> $Multiset$ এর ম্যাক্সিমাম ভ্যালুঃ

$if(mset.size() != 0) \lbrace$

$\quad it = mset.end();$

$\quad it- -;$

$\quad maximum = *it;$

$\rbrace$

My Solution: [Click Here](https://ideone.com/edXIKI)